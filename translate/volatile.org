#+TITLE:[译] 为什么不应该使用“volatile”
#+AUTHOR: Bei Fang
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../style.css"/>
#+OPTIONS: ^:nil
[[https://adeepmind.github.io/index.html][Home]]

原文链接：[[https://www.kernel.org/doc/html/latest/process/volatile-considered-harmful.html]]

C程序员经常使用volatile来表示一个可在当前执行线程外部修改的变量；因此，在内核代码中，当共享数据结构时，他们有时会试图用它。换句话说，他们把volatile类型视为简单的原子变量，然而它们并不是。在内核代码中使用volatile基本上都是错的，此文章就描述了其原因。

要知道关于volatile的关键点是它的目的是为了防止优化，这几乎并不是我们想要的。在内核中，必须保护共享数据结构防止意外的并发访问，这是一个非同寻常的任务。防止意外并发的过程将也是避免几乎所有优化带来相关联的问题的有效方式。

与volatile类似，内核原语使得并发访问数据安全(自旋锁，互斥锁，内存屏障等)的设计为了防止不必要的优化。如果它们使用得当,也就不需要volatile了。如果仍然需要volatile，那几乎可以肯定代码中存在bug。在正确编写的内核中，volatile只会让速度变慢。

考虑下面的一块内核代码：

#+BEGIN_SRC c
spin_lock(&the_lock);
do_something_on(&shared_data);
do_something_else_with(&shared_data);
spin_unlock(&the_lock);
#+END_SRC

如果所有代码都遵循锁定规则，则当在拥有锁时，shared_data的值不会被意外更改。在锁定的时候，任何想要访问数据的其他代码将等待。自旋锁原语充当内存屏障-它们显式的写入-意味着通过它们访问数据不会被优化。所以编译器可能知道shared_data中是什么，但是spin_lock()的调用充当内存屏障将会强制它忘记所知道的东西，如此访问数据将不会出现优化问题。

如果shared_data被声明为volatile，仍然需要锁。但是当我们知道没有人使用它时，编译器也会被阻止对shared_data访问临界区块的优化。当锁被拥有的时候，shared_data不是volatile。当处理共享数据的时候，锁可能会使volatile不必要-并且可能有害。

volatile存储类之前是为了内存映射I/O寄存器。在内核中，寄存器的访问也应该通过锁保护，但是也不想编译器对寄存器访问临界区块进行“优化”。 然而，在内核中，I/O内存访问总是通过访问器函数完成的；通过指针直接访问I/O内存是不受欢迎的，并且不适用所有的体系结构。那些访问函数是为了防止意外的优化， 因此再一次不需要volatile。

另一种诱导你使用volatile的情况可能是当处理器忙等一个变量的值时。执行忙等的正确方式：

#+BEGIN_SRC c
while (my_variable != what_i_want)
  cpu_relax();
#+END_SRC

cpu_relax()的调用可以降低CPU的功耗或者屈服一个超线程双处理器；它也恰好充当了编译器的屏障，因此，再一次不需要volatile。当然忙等通常是一个反社会行为。

在内核中，还有一些罕见的情况使volatile有意义：

+ 上述提到的访问器函数可能在直接I/O内存访问的体系结构中使用volatile。本质上，每个访问器调用本身都成为了一个小的临界区块，并确保访问按照程序员的预期发生。

+ 内联更改内存的汇编代码，但是没有其他可见的副作用，有被GCC删除的风险。在asm语句上添加volatile关键字可以防止被删除。

+ jiffies变量(译者注：内核中的一个全局变量，在jiffies.h文件中)的特殊之处在于它每次引用时都可以有不同的值，但是可以在没有任何锁定的情况下访问它。所以jiffies可以是volatile，但是在这个类型上添加其他变量是极其不受欢迎的。jiffies被认为是一个“愚蠢的遗产”的问题（Linus说的）；修理它所付的代价比它本身的价值要大。

+ 指向可能被I/O设备修改的连续的数据结构的指针，这种情况下有时候volatile是合法的。此情况的一个例子，一个使用环形缓冲区的网络适配器更改指针指向被处理过的描述符。

对于大多数代码，除了上述适用volatile的应用外均不适用。因此，使用volatile会被视为一个bug，并将对代码进行额外的审查。那些想要使用volatile的程序员应该退一步思考他们真正想实现什么。

删除volatile变量的修补程序是受欢迎的-只要他们有理由证明并发问题已得到适当的考虑。

- 自旋锁 :: 自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。

- 互斥锁 :: 互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。
